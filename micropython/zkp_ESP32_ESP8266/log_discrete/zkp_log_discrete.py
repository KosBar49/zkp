import random
import utime

class DiscreteLogInteractive():

    def __init__(self, g, y, p, x=None):
        """
        :param g: generator
        :param y: public key
        :param p: modulo
        :param x: secret
        """
        self._g = g
        self._y = y
        self._p = p
        self._x = x
        self._random = random

    def commitment(self):
        """
        :return: commitment (g^r mod p)
        """
        self._r = self._random.getrandbits(self._p - 1)
        commitment = pow(self._g, self._r) % self._p
        return commitment

    def challenge(self):
        """        
        :return: challenge (x * c + r mod p - 1)
        """
        self._challenge = self._random.getrandbits(self._p - 1)
        return self._challenge

    def response(self, challenge):
        """
        :param challenge: The challenge generated by the verifier

        :return: response (x * c + r mod p - 1)
        """
        return (self._x * challenge + self._r) % (self._p - 1)

    def verify(self, response, commitment):
        """
        :param response: The response generated by the prover
        :param commitment: The commitment generated by the prover
        """
        assert pow(self._g, response) % self._p == (
            pow(self._y, self._challenge) * commitment) % self._p
        
if __name__ == "__main__":
    
    g = 2
    x = 3
    P = g ** x
    p = 5
    
    client_a = DiscreteLogInteractive(g, P, p, x)
    client_b = DiscreteLogInteractive(g, P, p)
    
    start_response = utime.ticks_us()
    
    t = client_a.commitment()
    c = client_b.challenge()
    s = client_a.response(c)
    
    end_response = utime.ticks_us()
    
    client_b.verify(s, t)
    
    end_verify = utime.ticks_us()
    
    print( f"time of verify: {end_verify - end_response:.3f}" )
    print( f"time of response: {end_response - start_response:.3f}" )