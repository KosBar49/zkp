import random
from abc import ABC, abstractmethod
import hashlib

from Crypto.Util.number import getPrime
from Crypto.Random import get_random_bytes

class ZeroKnowledgeProtocol(ABC):
    @abstractmethod
    def response(self, statement):
        pass

    @abstractmethod
    def challenge(self):
        pass

    @abstractmethod
    def verify(self, statement, proof):
        pass


class DiscreteLogInteractive(ZeroKnowledgeProtocol):

    def __init__(self, g, y, p, x = None):
        """
        :param g: generator
        :param y: public key
        :param p: modulo
        :param x: secret
        """
        self._g = g
        self._y = y
        self._p = p 
        self._x = x
    
    def commitment(self):
        """
        :return: commitment (g^r mod p)
        """
        self._r = random.randint(0, self._p - 1)
        commitment = pow(self._g, self._r, self._p)
        return commitment
    
    def challenge(self):
        """        
        :return: challenge (x * c + r mod p - 1)
        """
        self._challenge = random.randint(1, self._p - 1)
        return self._challenge
    
    def response(self, challenge):
        """
        :param challenge: The challenge generated by the verifier

        :return: response (x * c + r mod p - 1)
        """
        return ( self._x * challenge + self._r ) % (self._p - 1)

    def verify(self, response, commitment):
        """
        :param response: The response generated by the prover
        :param commitment: The commitment generated by the prover
        """
        assert pow( self._g, response, self._p ) == ( pow(self._y, self._challenge) * commitment ) % self._p

class DiscreteLogNonInteractive(ZeroKnowledgeProtocol):
    
    def __init__(self, g, y, p, x = None):
        """
        :param g: generator
        :param y: public key
        :param p: modulo
        :param x: secret
        """
        self._g = g
        self._p = p
        self._y = y
        self._x = x

    def challenge(self):
        chal = str(self._g) + str(self._x) + str(self._y)
        h = hashlib.md5()
        h.update(chal.encode())
        self._v = random.randint(0, self._p - 1)
        V = pow(self._g, self._v, self._p)
        self._c = int(h.hexdigest(), 16)
        return self._c, V

    def response(self):
        return (self._v - self._c * self._x) % (self._p - 1)

    def verify(self, r, c, V):
        check = (pow(self._g, r, self._p) * pow(self._y, c, self._p)) % self._p
        assert V == check
